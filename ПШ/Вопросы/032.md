---
Приоритет:
  - ГЛАВНЫЙ
Direction:
  - "[[ПШ]]"
Discipline: Объектно-ориентированное программирование
tags:
  - готово
---
[[031.md|<< Предыдущий вопрос]] | [[033.md|Следующий вопрос >>]]
## Вопрос
Методы и классы final. Методы и классы abstract. Класс Object. Методы класса Object. Клонирование объектов.

### Что возможно нужно будет рассказать?
Этот вопрос охватывает фундаментальные конструкции Java:
- Запрет на **наследование** и **переопределение** (`final`).
- Объявление **абстрактных классов и методов**, которые требуют реализации.
- Класс `Object` как **родитель всех классов в Java**, и поведение его методов.
- Механизм **поверхностного и глубокого клонирования**, реализация интерфейса `Cloneable`, переопределение метода `clone()`.
#### ⚠️ Подводные камни:
- Путают **`abstract` и `interface`** — хотя вопрос про `abstract`, это важно уточнить.
- Думают, что `final` класс = "константный класс".
- Переопределение `clone()` требует соблюдения **жестких условий** (иначе — `CloneNotSupportedException`).
- Не понимают разницу между **поверхностным (shallow)** и **глубоким (deep)** клонированием.
---
## Ответ
### **2.1 Классы и методы `final`**
- `final class` — **нельзя наследовать**:
```java
final class Utils { }
class MyUtils extends Utils {} // ошибка
```

- `final method` — **нельзя переопределить в подклассе**:
```java
class Base {
    final void show() {}
}
class Derived extends Base {
    void show() {} // ошибка
}
```

> Используется для **безопасности, неизменности, оптимизации (JIT)**.

---
### **2.2 Классы и методы `abstract`**
- `abstract class` — нельзя создать экземпляр напрямую. Может содержать абстрактные и конкретные методы. Абстрактные методы **должны быть реализованы** в первом не-абстрактном потомке.

```java
abstract class Shape {
    abstract double area();
}

class Circle extends Shape {
    double area() { return Math.PI * r * r; }
}
```
#### 2.2.1 Отличие от `interface`:
Абстрактный класс может содержать:
- поля,
- конструкторы,
- нестатические методы с реализацией.

---
### **2.3 Класс `Object`**
Родитель **всех классов** в Java (`java.lang.Object`). Методы:
- `toString()` — строковое представление.
- `equals(Object)` — сравнение по умолчанию по ссылке.
- `hashCode()` — связан с `equals()`, используется в коллекциях.
- `clone()` — создаёт копию объекта (см. ниже).
- `getClass()` — возвращает `Class<?>`.
- `finalize()` — устарел (до Java 9+).
- `wait()`, `notify()`, `notifyAll()` — для потоков (см. другие вопросы).

---
### **2.4 Клонирование объектов**
Метод `clone()` объявлен в классе `Object`:
```java
protected native Object clone() throws CloneNotSupportedException;
```

- Чтобы клонировать объект:
    1. Класс должен реализовать **интерфейс `Cloneable`**.
    2. Метод `clone()` должен быть **переопределён** с `public` доступом.
    3. Без этого — **исключение** `CloneNotSupportedException`.
#### 2.4.1 Поверхностное клонирование:
Только копия **примитивов и ссылок**, не содержимого объектов.
```java
public class Person implements Cloneable {
    String name;
    public Person clone() throws CloneNotSupportedException {
        return (Person) super.clone(); // shallow copy
    }
}
```
#### 2.4.2 Глубокое клонирование:
Нужно вручную **клонировать вложенные объекты**:
```java
public class Employee implements Cloneable {
    Address address;

    public Employee clone() throws CloneNotSupportedException {
        Employee copy = (Employee) super.clone();
        copy.address = address.clone(); // если Address тоже Cloneable
        return copy;
    }
}
```
#### 2.4.3 Альтернатива:
- Использование **сериализации** или **копирующих конструкторов** как более надёжный способ глубокого клонирования.

---
## Ссылки
