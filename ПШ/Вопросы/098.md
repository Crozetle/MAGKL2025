---
Приоритет:
  - ГЛАВНЫЙ
Direction:
  - "[[ПШ]]"
Discipline: Задачи
tags:
  - готово
---
[[097.md|<< Предыдущий вопрос]] | [[099.md|Следующий вопрос >>]]
## Вопрос
Определить в бинарном дереве ближайший родительский узел для двух заданных узлов, если у каждого узла помимо ссылок на дочерние узлы есть ссылка на родительский узел.

---
У нас есть **бинарное дерево** — структура данных, в которой каждый узел (элемент) может иметь максимум два дочерних узла (левый и правый).  
Кроме этого, каждый узел содержит ссылку на своего **родительского** узла.

**Нужно:**  
Найти ближайший общий родительский узел (Lowest Common Ancestor, LCA) для двух заданных узлов.

То есть, нам надо найти узел, который является предком (родителем, или родителем родителя и т.д.) для обоих заданных узлов и при этом находится как можно глубже в дереве (ближе к самим узлам).

```
         A
        / \
       B   C
      / \
     D   E
```

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.parent = None
        self.left = None
        self.right = None

def get_depth(node):
    depth = 0
    while node:
        node = node.parent
        depth += 1
    return depth

def find_lowest_common_ancestor(n1, n2):
    depth1 = get_depth(n1)
    depth2 = get_depth(n2)

    while depth1 > depth2:
        n1 = n1.parent
        depth1 -= 1
    while depth2 > depth1:
        n2 = n2.parent
        depth2 -= 1

    while n1 != n2:
        n1 = n1.parent
        n2 = n2.parent

    return n1

# Пример
A = Node('A')
B = Node('B')
C = Node('C')
D = Node('D')
E = Node('E')

A.left = B; B.parent = A
A.right = C; C.parent = A
B.left = D; D.parent = B
B.right = E; E.parent = B

lca = find_lowest_common_ancestor(D, E)
print("LCA для D и E:", lca.value)  # Выведет: B
```

---

```java
class Node {
    int value;
    Node parent;
    Node left;
    Node right;

    Node(int val) {
        this.value = val;
    }
}

public class BinaryTree {
    // Получить высоту узла (число предков до корня)
    private static int getDepth(Node node) {
        int depth = 0;
        while (node != null) {
            node = node.parent;
            depth++;
        }
        return depth;
    }

    // Найти ближайшего общего родителя для two узлов
    public static Node findLowestCommonAncestor(Node n1, Node n2) {
        int depth1 = getDepth(n1);
        int depth2 = getDepth(n2);

        // Поднимаем более глубокий узел вверх, чтобы выровнять уровни
        while (depth1 > depth2) {
            n1 = n1.parent;
            depth1--;
        }
        while (depth2 > depth1) {
            n2 = n2.parent;
            depth2--;
        }

        // Поднимаемся вместе, пока узлы не совпадут
        while (n1 != n2) {
            n1 = n1.parent;
            n2 = n2.parent;
        }
        return n1;  // или n2 — они равны здесь
    }

    public static void main(String[] args) {
        // Пример создания дерева:
        Node A = new Node(1);
        Node B = new Node(2);
        Node C = new Node(3);
        Node D = new Node(4);
        Node E = new Node(5);

        A.left = B; B.parent = A;
        A.right = C; C.parent = A;
        B.left = D; D.parent = B;
        B.right = E; E.parent = B;

        Node lca = findLowestCommonAncestor(D, E);
        System.out.println("LCA для D и E: " + lca.value);  // Выведет 2 (узел B)
    }
}
```
## Ссылки
