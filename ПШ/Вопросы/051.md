---
Приоритет:
  - ГЛАВНЫЙ
Direction:
  - "[[ПШ]]"
Discipline: Разработка Web-приложений
tags:
  - готово
---
[[050.md|<< Предыдущий вопрос]] | [[052.md|Следующий вопрос >>]]
## Вопрос
Servlet, Servlet container, Distributed servlet container, Servlet context, Servlet mapping. Жизненный цикл сервлетов. Особенности сервлетов. Объекты запроса и отклика. HTTP Servlet. Пример сервлета. Поддержка сессий. Общий дескриптор развёртывания web.xml. Фильтрация.

### Что возможно нужно будет рассказать?
Тема целиком про **Java Servlets** и связанные концепции.  

Экзаменатор ожидает:
- Понимание, что такое сервлет, роль контейнера сервлетов и сопутствующих элементов.
- Чёткое знание жизненного цикла сервлета (init → service → destroy).
- Умение объяснить назначение объектов запроса и ответа (`HttpServletRequest`, `HttpServletResponse`).
- Понимание, что такое `ServletContext`, `ServletConfig`, маппинг сервлетов, `web.xml`.
- Умение привести пример простого сервлета (GET/POST).
- Знание механизма поддержки сессий.
- Понимание фильтров в сервлетах.
#### Подводные камни:
- Не перепутать **Servlet Container** и **ServletContext** (контейнер — это среда выполнения, контекст — объект для взаимодействия с ней).
- Чётко различать **init()** (один раз при создании) и **service()** (каждый запрос).
- Уметь объяснить, зачем нужен **web.xml** даже при наличии аннотаций `@WebServlet`.
- Понимать разницу между обычным контейнером сервлетов и распределённым (distributed).

---
## Ответ
### 2.1. Servlet
Сервлет — это обычный Java-класс, который живёт внутри сервлет-контейнера и умеет принимать HTTP-запросы от клиента (чаще всего от браузера), обрабатывать их и отправлять обратно HTTP-ответ.  

Чтобы контейнер понял, что это сервлет, класс либо расширяет `HttpServlet`, либо реализует интерфейс `Servlet`.  

Применение сервлетов широкое: генерация HTML-страниц на лету, отдача JSON для AJAX-запросов, формирование XML-ответов для интеграции с другими системами.
### 2.2. Servlet Container
Сервлет-контейнер — это как «мини-сервер» внутри веб-сервера, который управляет сервлетами. Он:
- Загружает сервлеты в память.
- Запускает их и управляет их жизненным циклом (`init()`, `service()`, `destroy()`).
- Предоставляет API для работы с запросами и ответами (`HttpServletRequest`, `HttpServletResponse`).
- Реализует безопасность и маршрутизацию.

Примеры контейнеров: **Apache Tomcat**, **Jetty**, **WildFly**.
### 2.3. Distributed Servlet Container
Если приложение работает в кластере, нужен «распределённый» контейнер. Он:
- Умеет реплицировать сессии между разными узлами, чтобы пользователь мог переключиться на другой сервер без потери данных.
- Поддерживает балансировку нагрузки.

Например, в Tomcat можно включить кластерный режим, и тогда данные сессии будут автоматически передаваться между серверами.
### 2.4. Servlet Context
`ServletContext` — это объект, который контейнер предоставляет каждому веб-приложению. Он:
- Общий для всех сервлетов внутри приложения.
- Позволяет получать доступ к параметрам конфигурации (инициализационные параметры).
- Дает доступ к ресурсам приложения (файлам, потокам данных).
- Обеспечивает централизованное логирование.
### 2.5. Servlet Mapping
Чтобы контейнер знал, на какой сервлет отправить конкретный HTTP-запрос, используется _сопоставление_ URL-шаблонов и классов сервлетов.

```java
@WebServlet("/hello")
public class HelloServlet extends HttpServlet { ... }
```
### 2.6. Жизненный цикл сервлета
Когда сервлет попадает в контейнер, его жизнь проходит в три больших этапа:

1. **Инициализация — `init(ServletConfig config)`**  
    Как только контейнер решает, что сервлет пора использовать (обычно при первом запросе или при старте приложения, если так настроено), он:
    - Создаёт объект сервлета.
    - Вызывает `init()`, передавая объект `ServletConfig` с параметрами конфигурации.  
        Здесь удобно разместить код, который подготавливает ресурсы: подключение к БД, чтение конфигов, инициализация кэшей.  
        **Вызывается ровно один раз** за весь срок жизни объекта сервлета.

2. **Обслуживание запросов — `service(HttpServletRequest req, HttpServletResponse resp)`**  
    Каждый новый HTTP-запрос попадает в этот метод. В зависимости от метода запроса (`GET`, `POST`, `PUT`, `DELETE`) он внутри вызывает соответствующие методы (`doGet()`, `doPost()` и т.д.).  
    Важно помнить:
    - Контейнер использует один объект сервлета на все запросы.
    - Обработка запросов идёт в разных потоках → нужно следить за потокобезопасностью.

3. **Завершение работы — `destroy()`**  
    Когда приложение останавливается или контейнер решает выгрузить сервлет, вызывается `destroy()`.  
    Тут нужно корректно закрыть соединения, освободить ресурсы и выполнить финальную очистку.  
    После вызова `destroy()` объект сервлета становится кандидатом на сборку мусора.
Сервлеты — это не просто Java-классы, а компоненты, которые **живут внутри сервлет-контейнера** (Tomcat, Jetty, WildFly и др.). Контейнер полностью управляет их жизненным циклом, многопоточностью и взаимодействием с клиентами по протоколу HTTP.
### **1. Особенности работы сервлетов**
Запуск в контейнере означает, что сами сервлеты не принимают соединения напрямую — этим занимается контейнер, который передаёт запрос в метод `service()`.

Потокобезопасность — важная задача разработчика. Один экземпляр сервлета может обрабатывать десятки запросов одновременно в разных потоках. Если в сервлете есть изменяемые поля (например, счётчики или списки), доступ к ним нужно синхронизировать или хранить данные в локальных переменных метода.

Сервлет может работать с данными **трёх уровней**:
- **Запрос** (данные одного HTTP-запроса).
- **Сессия** (данные, общие для всех запросов одного пользователя).
- **Контекст приложения** (данные, общие для всех пользователей и всех сервлетов).
### **2. Объекты запроса и ответа**
При каждом HTTP-запросе контейнер создаёт два объекта и передаёт их в сервлет:

- **`HttpServletRequest`** — источник информации о запросе:
    - параметры (`getParameter()`), заголовки (`getHeader()`), HTTP-метод (`getMethod()`), тело запроса (например, JSON), объект сессии (`getSession()`).
- **`HttpServletResponse`** — инструмент для формирования ответа:
    - установка заголовков (`setHeader()`), HTTP-кода (`setStatus()`), отправка HTML/JSON/XML в тело ответа через `getWriter()` или `getOutputStream()`.
### **3. Класс `HttpServlet`**
Чтобы работать с HTTP проще, большинство сервлетов расширяют абстрактный класс **`HttpServlet`**, который уже реализует базовую логику:

Внутри `service()` он сам определяет, какой метод HTTP используется, и вызывает соответствующий:
- `doGet()` — обработка GET-запроса.
- `doPost()` — POST-запроса.
- `doPut()` — PUT-запроса.
- `doDelete()` — DELETE-запроса.

Это позволяет сосредоточиться на логике работы с данными, а не на деталях протокола.
### 2.10. Пример сервлета
```java
@WebServlet("/hello")
public class HelloServlet extends HttpServlet {

    @Override
    public void init() throws ServletException {
        // Инициализация сервлета (можно брать параметры из контекста)
        System.out.println("Servlet initialized");
    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {

        // Установка типа содержимого
        resp.setContentType("text/html;charset=UTF-8");

        // Доступ к параметру запроса
        String name = req.getParameter("name");
        if (name == null) name = "Guest";

        // Формирование ответа
        resp.getWriter().println("<h1>Hello, " + name + "!</h1>");
    }

    @Override
    public void destroy() {
        System.out.println("Servlet destroyed");
    }

    public static void main(String[] args) throws Exception {
        Server server = new Server(8080);

        // 2. Создаём контекст сервлетов
        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
        context.setContextPath("/"); // корневой путь приложения
        server.setHandler(context);

        // 3. Регистрируем сервлет
        context.addServlet(HelloServlet.class, "/hello");

        // 4. Запускаем контейнер
        server.start();
        server.join();
    }
}
```
### 2.11. Поддержка сессий
- HTTP — протокол без состояния, сессии нужны для сохранения данных между запросами.
- `HttpSession` — объект для хранения данных пользователя.
- Идентификатор сессии передаётся через cookie (JSESSIONID) или URL rewriting.
### 2.12. Общий дескриптор развёртывания `web.xml`
- XML-файл в `WEB-INF/` для конфигурации приложения.
- Настройки: маппинг сервлетов, инициализационные параметры, фильтры, слушатели.
### 2.13. Фильтрация
- Фильтры (`javax.servlet.Filter`) — перехватывают запросы/ответы для обработки до и после сервлета.
- Используются для логирования, аутентификации, сжатия, изменения заголовков.

---
## Ссылки

