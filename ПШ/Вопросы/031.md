---
Приоритет:
  - ГЛАВНЫЙ
Direction:
  - "[[ПШ]]"
Discipline: Объектно-ориентированное программирование
tags:
  - готово
---
[[030.md|<< Предыдущий вопрос]] | [[032.md|Следующий вопрос >>]]
## Вопрос
Сокрытие полей. Доступ к унаследованным членам. Возможность доступа и переопределение. Сокрытие статических членов. Служебное слово super. Проверка типа.

### Что возможно нужно будет рассказать?
Этот вопрос проясняет **тонкие различия между переопределением и сокрытием**, а также поведение **доступа к членам суперкласса** (особенно полям и методам). Также поднимаются **важные аспекты статических членов**, которые **не переопределяются**, а **скрываются**, что часто ведёт к логическим ошибкам.
#### ⚠️ Подводные камни:
- **Переопределение ≠ сокрытие** — это разные механизмы.
- **Поля не переопределяются**, они **скрываются**.
- Статические методы **не участвуют в полиморфизме**.
- **`super`** работает только на **один уровень вверх**.
- Неверное использование `instanceof` или unsafe casting приводит к `ClassCastException`.

---
## Ответ
### **2.1 Сокрытие полей**
- Если в подклассе объявить поле с тем же именем, что и в суперклассе, оно **скрывает** оригинальное.
- Поведение зависит от **типа ссылки**, а не объекта:

```java
class Parent {
    int x = 10;
}
class Child extends Parent {
    int x = 20;
}

Parent obj = new Child();
System.out.println(obj.x); // 10, т.к. x определяется по типу ссылки
```

> Поля не подлежат переопределению. Это **сокрытие**, не **переопределение**.

---
### **2.2 Доступ к унаследованным членам**
- Можно обращаться к методам и полям суперкласса через `super`, если они не `private`.
```java
class Child extends Parent {
    void printX() {
        System.out.println(super.x); // доступ к полю родителя
    }
}
```

---
### **2.3 Возможность доступа и переопределение методов**
- Методы можно переопределять, если они **не `private`, не `final`, не `static`**.
- Доступ к унаследованному методу — по обычным правилам (модификаторы доступа).
- `super.method()` — вызов версии из родительского класса.

|Особенность|Поля|Обычные методы|Статические методы|
|---|---|---|---|
|Наследуются|✅ Да|✅ Да|✅ Да|
|Переопределяются|❌ Нет (сокрытие)|✅ Да|❌ Нет (сокрытие)|
|Динамический диспетчинг|❌ Нет (по типу переменной)|✅ Да (по типу объекта)|❌ Нет (по типу переменной)|
|Вызываются через|`this`, `super`|`this`, `super`|`ClassName` (рекомендуется)|

---
### **2.4 Сокрытие статических членов**
- Статические методы и поля **не переопределяются**, а **скрываются**.

```java
class Parent {
    static void hello() {
        System.out.println("Parent");
    }
}
class Child extends Parent {
    static void hello() {
        System.out.println("Child");
    }
}
```

```java
Parent p = new Child();
p.hello(); // "Parent"
Child c = new Child();
c.hello(); // "Child"
```

- Выбор метода — **на этапе компиляции**, по **типу ссылки**.

---
### **2.5 Служебное слово `super`**
Используется:
- для вызова **конструктора родительского класса** (см. вопрос 30),
- для вызова **методов** и **полей** суперкласса, скрытых или переопределённых в текущем классе.

```java
super.methodName();
super.fieldName;
```

```java
class Parent {
    int x = 10;
    static void staticMethod() {
        System.out.println("Parent staticMethod");
    }
    void instanceMethod() {
        System.out.println("Parent instanceMethod");
    }
}

class Child extends Parent {
    int x = 20; // сокрытие поля

    static void staticMethod() {
        System.out.println("Child staticMethod"); // сокрытие, не переопределение!
    }

    @Override
    void instanceMethod() {
        System.out.println("Child instanceMethod");
    }

    void show() {
        System.out.println("this.x = " + this.x);   // 20
        System.out.println("super.x = " + super.x); // 10

        this.instanceMethod();  // Child version (переопределён)
        super.instanceMethod(); // Parent version

        Child.staticMethod();   // Child
        Parent.staticMethod();  // Parent
    }
}
```

---
### **2.6 Проверка типа**
- Оператор `instanceof`:
```java
if (obj instanceof Child) { ... }
```

- Приведение типа:
```java
Parent p = new Child();
Child c = (Child) p; // безопасно, если действительно Child
```
Используется при **вызове метода, специфичного для подкласса**.

---
## Ссылки
