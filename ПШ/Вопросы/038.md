---
Приоритет:
  - ГЛАВНЫЙ
Direction:
  - "[[ПШ]]"
Discipline: Объектно-ориентированное программирование
tags:
  - готово
---
[[037.md|<< Предыдущий вопрос]] | [[039.md|Следующий вопрос >>]]
## Вопрос
Проблемы однопоточного подхода. Особенности многопоточности. Использование класса Thread. Использование интерфейса Runnable. Приоритеты потоков.

### Что возможно нужно будет рассказать?
Вопрос открывает тему **многопоточности** в Java, и делится на несколько ключевых блоков:
- **Проблемы однопоточного подхода** — почему одной нити выполнения может быть недостаточно.
- **Особенности многопоточности** — что это такое, зачем нужна, какие плюсы и подводные камни.
- **Создание потоков**:
    - Через **наследование от `Thread`**
    - Через **реализацию интерфейса `Runnable`**
- **Приоритеты потоков** — что это, как задаются, и почему в реальности часто игнорируются JVM.
#### ⚠️ Подводные камни:
- **Путают `Thread` и `Runnable`**: часто не осознают, почему предпочтительнее `Runnable`.
- Думают, что **поток запускается при вызове `.run()`**, а не `.start()`.
- Считают, что **приоритеты гарантируют порядок выполнения** (в реальности — это рекомендация для планировщика ОС, не гарантия).
- Не понимают, **чем многопоточность отличается от параллельности и асинхронности**.

---
## Ответ
### **2.1 Проблемы однопоточного подхода**
Выполнение задач поочерёдно → неэффективно для:
- пользовательского интерфейса
- сетевых запросов
- интенсивных вычислений в фоновом режиме

В однопоточном приложении всё выполняется **последовательно** — одна задача за другой. Это приводит к таким проблемам:
- **Зависания интерфейса:** если программа, например, читает большой файл или ждет ответа с сервера, весь интерфейс "замерзает", перестаёт отвечать на клики и ввод пользователя.
- **Неэффективное использование ресурсов:** пока программа ждёт медленного запроса (сети, файловой системы), процессор простаивает.
- **Низкая отзывчивость:** пользователь чувствует задержки, приложение кажется медленным.

**Пример**: в GUI-приложении всё "замерзает" при длительном выполнении операции.

---
### **2.2 Основы многопоточности**
Многопоточность позволяет выполнять **несколько задач параллельно или псевдопараллельно**.
- **Поток (Thread)** — отдельная "ниточка" исполнения кода.
- JVM запускает программу с одним потоком — `main`.
- Можно создавать новые потоки, чтобы, например, обработать загрузку файла в фоне, не блокируя основной интерфейс.

```java
public class MyThread extends Thread {
    public void run() {
        System.out.println("Выполняется в отдельном потоке");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();  // Запуск нового потока (вызывает run() асинхронно)
        System.out.println("Основной поток");
    }
}
```

---
### **2.3 Использование класса `Thread`**
- Наследуется от `java.lang.Thread`.
- Переопределяется метод `run()`.

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Выполняется в другом потоке");
    }
}
new MyThread().start(); // ⚠️ важно: start(), а не run()
```

> Важно: вызываешь **не `run()` напрямую**, а `start()` — он создаст ОС-поток и запустит `run()` асинхронно.

---
### **2.4 Использование интерфейса `Runnable`**
Лучше с точки зрения **ООП и масштабируемости** (можно реализовать в любом классе, не ограничен одиночным наследованием). Вместо наследования от `Thread`, реализуешь интерфейс `Runnable` в любом классе (плюс: нет ограничений на наследование, можно реализовать логику в классе, который уже наследует другой класс).

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Выполняется в потоке");
    }
}

public class Main {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable());
        t.start();
    }
}
```
#### Ключевые преимущества Runnable над наследованием Thread:
- Свобода наследования: класс может наследоваться от другого класса и при этом реализовать `Runnable`.
- Код легче комбинировать, передавать и переиспользовать.
- Позволяет использовать более сложные средства управления потоками (например, `ExecutorService`), где нужна логика выполнения отдельно от самого потока.

---
### **2.5 Приоритеты потоков**
Используется метод `setPriority(int)`:
- `Thread.MIN_PRIORITY` (1)
- `Thread.NORM_PRIORITY` (5 — по умолчанию)
- `Thread.MAX_PRIORITY` (10)

```java
Thread t = new Thread(() -> { ... });
t.setPriority(Thread.MAX_PRIORITY);
```

- Это **рекомендация**, а **не жёсткое правило**.
- JVM **может проигнорировать** приоритет — особенно в системах с собственным планировщиком (например, Linux).
- В реальности **порядок выполнения определяет планировщик ОС**, а не твой вызов `setPriority()`.

---
## Ссылки
