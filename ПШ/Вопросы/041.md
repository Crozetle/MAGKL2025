---
Приоритет:
  - ГЛАВНЫЙ
Direction:
  - "[[ПШ]]"
Discipline: Объектно-ориентированное программирование
tags:
  - готово
  - сложно
---
[[040.md|<< Предыдущий вопрос]] | [[042.md|Следующий вопрос >>]]
## Вопрос
Пакет java.util.concurrent. ReentrantLock, ReadWriteLock. Интерфейсы Callable и Future. Интерфейсы Executor, ExecutorService, ScheduledExecutorService. Пул потоков. Executors.

### Что возможно нужно будет рассказать?
Здесь надо раскрыть **новейшие средства Java для управления многопоточностью**, обеспечивающие:
- Более гибкий контроль блокировок (`ReentrantLock`, `ReadWriteLock`).
- Возможность запуска задач с возвратом результата (`Callable` + `Future`).
- Управление потоками через **пулы и планировщики** (`ExecutorService`, `ScheduledExecutorService`).
- Понимание, зачем нужны пулы потоков, и как они оптимизируют производительность и ресурсы.
#### Подводные камни:
- Ошибочное использование `ReentrantLock` без правильного вызова `unlock()`.
- Путаница между `Executor` и `ExecutorService`.
- Непонимание разницы между `Callable` и `Runnable`.
- Пренебрежение обработкой исключений в `Future`.
- Отсутствие понимания важности пула потоков — создание новых потоков напрямую плохо влияет на производительность.

---
## Ответ
### 2.1 Пакет `java.util.concurrent`
- Общее назначение пакета: расширение и улучшение классических примитивов синхронизации.
- Основные компоненты и интерфейсы.

---
### 2.2 ReentrantLock и ReadWriteLock
- **ReentrantLock**: преимущества перед `synchronized` (например, возможность прерывания блокировки, попытка захвата, справедливость).
- Методы `lock()`, `unlock()`, `tryLock()`.
- Обязательное вызовы `unlock()` в блоке `finally`.
- **ReadWriteLock** (чаще `ReentrantReadWriteLock`):
    - Разделение на **чтение и запись**: несколько потоков могут читать одновременно, запись эксклюзивна.
    - Пример использования для оптимизации доступа к данным.

---
### 2.3 Callable и Future
- `Callable<V>` — задача, возвращающая результат и допускающая выброс проверяемых исключений.
- Отличие от `Runnable` (не возвращает значение и не кидает checked exceptions).
- `Future<V>` — результат асинхронной операции.
- Методы `get()`, `cancel()`, `isDone()`.
- Пример использования: запуск задачи и получение результата позже.

---
### 2.4 Интерфейсы Executor, ExecutorService, ScheduledExecutorService
- **Executor** — базовый интерфейс для запуска задач.
- **ExecutorService** — расширенный интерфейс с возможностью управления жизненным циклом пула.
- Методы `submit()`, `shutdown()`, `awaitTermination()`.
- **ScheduledExecutorService** — для планирования задач с задержкой или периодически.

---
### 2.5 Пул потоков и класс Executors
- Зачем нужен пул потоков? (экономия ресурсов, управление количеством потоков)
- Статические фабричные методы класса `Executors`:
    - `newFixedThreadPool(int)`
    - `newCachedThreadPool()`
    - `newSingleThreadExecutor()`
    - `newScheduledThreadPool()`
- Пример: создание пула и запуск задач.

---
### 2.6 Рекомендации по примерам
- Код с использованием **ReentrantLock** для критической секции.
- Пример чтения/записи с использованием `ReentrantReadWriteLock`.
- Пример запуска `Callable` через `ExecutorService` и получение результата через `Future`.
- Пример планирования задачи через `ScheduledExecutorService`.
- Пример создания пула с помощью `Executors` и запуска нескольких задач.

---
## Ссылки
