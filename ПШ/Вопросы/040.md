---
Приоритет:
  - ГЛАВНЫЙ
Direction:
  - "[[ПШ]]"
Discipline: Объектно-ориентированное программирование
tags:
  - сложно
  - готово
---
[[039.md|<< Предыдущий вопрос]] | [[041.md|Следующий вопрос >>]]
## Вопрос
Совместное использование ресурсов. Характерные ошибки. volatile. Специальные методы класса Object. Особенности использования методов класса Object.

### Что возможно нужно будет рассказать?
Этот вопрос касается **проблем синхронизации при доступе к разделяемым данным в многопоточном контексте**. Также он раскрывает **низкоуровневые механизмы синхронизации**, встроенные в Java ещё с ранних версий (`wait()`, `notify()`, `notifyAll()`), и взаимодействие с ключевым словом `volatile`.
#### ⚠️ Подводные камни:
- Недооценка **проблем гонки (race condition)** и **состояний гонки**.
- Путаница между `volatile` и `synchronized`.
- Неправильное или небезопасное использование `wait()` / `notify()`.
- Отсутствие понимания **монитора объекта** как механизма блокировки.
- Использование `wait()` вне `synchronized`-блока приводит к `IllegalMonitorStateException`.

---
## Ответ
### **2.1 Совместное использование ресурсов**
- **Состояния гонки (race conditions)** при доступе к полям из нескольких потоков.
- Пример: инкремент счетчика без синхронизации → неправильное значение.
- **Критическая секция** и необходимость её защиты.

```java
static int counter = 0;

public static void main(String[] args) throws InterruptedException {
	Runnable task = () -> {
		for (int i = 0; i < 1000; i++) {
			counter++; // ❗ НЕ синхронизированная операция
		}
	};

	Thread t1 = new Thread(task);
	Thread t2 = new Thread(task);

	t1.start();
	t2.start();

	t1.join(); // дождаться завершения
	t2.join();

	System.out.println("Итоговое значение: " + counter);
}

// Ожидаемое значение: `2000`
// Реальное значение: меньше (например, 1721, 1935 и т.п.)
```

```java
static int counter = 0;

public static void main(String[] args) throws InterruptedException {
	Runnable task = () -> {
		for (int i = 0; i < 1000; i++) {
			synchronized (RaceConditionExample.class) {
			    counter++;
			}
		}
	};

	Thread t1 = new Thread(task);
	Thread t2 = new Thread(task);

	t1.start();
	t2.start();

	t1.join(); // дождаться завершения
	t2.join();

	System.out.println("Итоговое значение: " + counter);
}
```

---
### **2.2 Характерные ошибки при доступе к разделяемым ресурсам**
| Тип ошибки                                                       | Описание                                                                                   | Способ устранения                                                                                         |
| ---------------------------------------------------------------- | ------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------- |
| **Гонка (Race condition)**                                       | Несинхронизированный доступ к общим данным, приводит к некорректному состоянию или данным. | Использовать `synchronized`, атомарные классы или блокировки (`Lock`).                                    |
| **Синхронизация на разных объектах**                             | Потоки синхронизируются на разных объектах, что не защищает общий ресурс должным образом.  | Синхронизировать на одном общем мониторе (объекте).                                                       |
| **Взаимная блокировка (Deadlock)**                               | Потоки ждут освобождения ресурсов друг от друга, в итоге ни один не продолжает выполнение. | Избегать вложенных блокировок, использовать таймауты, строгий порядок захвата блокировок.                 |
| **Зависание при неправильном использовании `wait()`/`notify()`** | Поток навсегда ожидает уведомления, которое не приходит, или уведомление теряется.         | Вызывать `wait()` внутри цикла с условием, использовать `notifyAll()`, правильно синхронизировать доступ. |
#### 1. Гонка (Race condition)`
```java
class Counter {
    int count = 0;

    public void increment() {
        count++; // Несинхронизированный доступ
    }
}

public class RaceConditionDemo {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println(counter.count); // Ожидается 2000, но будет меньше из-за гонки
    }
}
```

**Решение:** синхронизировать метод или использовать атомарный тип
```java
public synchronized void increment() {
    count++;
}

// или

import java.util.concurrent.atomic.AtomicInteger;

class Counter {
    AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet();
    }
}
```
#### 2. Синхронизация на разных объектах (неэффективная синхронизация)
```java
class SharedResource {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    int value = 0;

    public void increment() {
        synchronized(lock1) {
            value++;
        }
    }

    public void decrement() {
        synchronized(lock2) {
            value--;
        }
    }
}
```
**Проблема:** `increment()` и `decrement()` синхронизированы на разных объектах, возможны гонки при доступе к `value`.

**Решение:** синхронизировать на одном объекте
```java
class SharedResource {
    private final Object lock = new Object();
    int value = 0;

    public void increment() {
        synchronized(lock) {
            value++;
        }
    }

    public void decrement() {
        synchronized(lock) {
            value--;
        }
    }
}
```
#### 3. Взаимная блокировка (Deadlock)
```java
public class DeadlockDemo {
    private final Object lockA = new Object();
    private final Object lockB = new Object();

    public void method1() {
        synchronized(lockA) {
            System.out.println("Thread 1: Locked lockA");
            try { Thread.sleep(100); } catch (InterruptedException e) {}
            synchronized(lockB) {
                System.out.println("Thread 1: Locked lockB");
            }
        }
    }

    public void method2() {
        synchronized(lockB) {
            System.out.println("Thread 2: Locked lockB");
            try { Thread.sleep(100); } catch (InterruptedException e) {}
            synchronized(lockA) {
                System.out.println("Thread 2: Locked lockA");
            }
        }
    }

    public static void main(String[] args) {
        DeadlockDemo demo = new DeadlockDemo();

        new Thread(demo::method1).start();
        new Thread(demo::method2).start();
    }
}
```
**Проблема:** `Thread 1` держит `lockA` и ждёт `lockB`, `Thread 2` держит `lockB` и ждёт `lockA` → взаимная блокировка.

**Решение:** соблюдать порядок захвата блокировок
```java
public void method1() {
    synchronized(lockA) {
        System.out.println("Thread 1: Locked lockA");
        synchronized(lockB) {
            System.out.println("Thread 1: Locked lockB");
        }
    }
}

public void method2() {
    synchronized(lockA) {  // Теперь тот же порядок захвата
        System.out.println("Thread 2: Locked lockA");
        synchronized(lockB) {
            System.out.println("Thread 2: Locked lockB");
        }
    }
}
```
#### 4. Зависание при неправильном использовании `wait()`/`notify()`
```java
class WaitNotifyDemo {
    private final Object lock = new Object();

    public void waitingThread() throws InterruptedException {
        synchronized(lock) {
            System.out.println("Waiting...");
            lock.wait();  // Если notify не вызовут, поток будет ждать вечно
            System.out.println("Notified!");
        }
    }

    public void notifyingThread() {
        synchronized(lock) {
            // Если вызвать notify до wait, notify "потеряется"
            lock.notify();
        }
    }
}
```
**Проблема:** если `notify()` вызван до `wait()`, уведомление потеряется и поток будет ждать навсегда.

**Решение:** вызывать `wait()` в цикле с проверкой условия и использовать `notifyAll()`
```java
class WaitNotifyDemo {
    private final Object lock = new Object();
    private volatile boolean condition = false;

    public void waitingThread() throws InterruptedException {
        synchronized(lock) {
            while (!condition) { // цикл проверяет условие
                lock.wait();
            }
            System.out.println("Condition met, proceeding...");
        }
    }

    public void notifyingThread() {
        synchronized(lock) {
            condition = true;
            lock.notifyAll(); // уведомляем всех ожидающих
        }
    }
}
```

---
### **2.3 Ключевое слово `volatile`**
- Гарантирует **видимость изменений переменной между потоками**.
- Не гарантирует **атомарность** операций!
- Хорошо работает для флагов типа "остановить поток", но **не подходит для инкрементов, счётчиков и сложных структур данных**.

```java
volatile boolean running = true;
```

📌 Привести **пример с флагом остановки потока**, пояснить, почему без `volatile` возможна "зависшая" логика.

---
### **2.4 Методы класса `Object`, применимые к синхронизации**
#### Основные моменты:
Каждый объект в Java ассоциирован с **монитором** — механизмом, который позволяет синхронизировать потоки. Чтобы вызвать `wait()`, `notify()`, `notifyAll()`, поток должен **захватить монитор объекта** (`synchronized`).
- `wait()` — поток **отпускает монитор и переходит в состояние ожидания** (до вызова `notify()` или `notifyAll()`).
- `notify()` — пробуждает **один** поток, ожидающий на данном объекте.
- `notifyAll()` — пробуждает **все** потоки, ожидающие на данном объекте.

После пробуждения поток пытается заново захватить монитор, чтобы продолжить работу.

📌 Все эти методы можно вызывать **только внутри синхронизированного блока/метода**:

```java
synchronized(obj) {
    obj.wait();
}
```

#### Используемые конструкции:
- `synchronized` блоки
- Монитор объекта (`this` или любой другой объект)

📌 Обязательно привести **схему работы монитора**: поток → захват монитора → `wait()` → освобождение → `notify()` → возврат → продолжение.

---

### **2.5 Особенности методов Object:**

|Метод|Описание|Условия|
|---|---|---|
|`wait()`|Ожидает сигнала на этом объекте|Только в synchronized|
|`notify()`|Сигнализирует одному потоку, ожидающему на объекте|Только в synchronized|
|`notifyAll()`|Сигнализирует всем ожидающим потокам|Только в synchronized|

```java
class SharedResource {
    private boolean ready = false;

    public synchronized void waitForReady() throws InterruptedException {
        while (!ready) {
            wait(); // отпускает монитор и ждёт notify
        }
        System.out.println("Ресурс готов, продолжаем работу");
    }

    public synchronized void setReady() {
        ready = true;
        notify(); // пробуждаем один ожидающий поток
    }
}

public class Main {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        Thread waitingThread = new Thread(() -> {
            try {
                resource.waitForReady();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        waitingThread.start();

        try {
            Thread.sleep(1000); // имитация подготовки ресурса
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        resource.setReady(); // сигнал потоку waitingThread
    }
}
```

---
## Ссылки
